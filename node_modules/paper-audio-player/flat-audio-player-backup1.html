<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../paper-progress/paper-progress.html">
<link rel="import" href="../iron-icon/iron-icon.html">
<link rel="import" href="../iron-icons/av-icons.html">

<!--
An element providing a solution to no problem in particular.

Example:

    <flat-audio-player></flat-audio-player>

@demo
-->
<dom-module id="flat-audio-player">

  <style>
    :host {
      display: block;
      box-sizing: border-box;
      width: 100%;
    }

    #wrapper {
      position: relative;
      cursor: pointer;
    }

    #icon {
      position: absolute;
      left: 4px;
      top: 4px;
    }

    #title {
      font-family: 'Roboto Mono', 'Helvetica Neue', Arial, sans-serif;
      position: absolute;
      width: 100%;
      line-height: 32px;
      z-index: 2;
      text-align: center;
      font-size: 15px;
    }

    :host paper-progress {
      position: relative;
      width: 100%;
      height: 28px;
      --paper-progress-container-color: rgba(255, 255, 255, .3);
      --paper-progress-active-color: #fff;
    }

    :host(.hovered) paper-progress {
      --paper-progress-container-color: rgba(255, 255, 255, .5);
    }

    paper-progress ::shadow #progressContainer.paper-progress {
      border-radius: 15px;
      border: 2px solid rgba(0,0,0,.12);
    }

    /*paper-progress:before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      width: 0;
      height: 0;
      border-top: 15px solid transparent;
      border-bottom: 15px solid transparent;
      border-left: 21px solid white;
      z-index: 1;
    }*/

  </style>

  <template>
    <div id="wrapper" on-click="playPause" on-mouseenter="onMouseenter" on-mouseleave="onMouseleave">

      <!-- Icon -->
      <iron-icon id="icon" icon="{{ icon }}"></iron-icon>
      <!--<iron-icon class="icon play" icon="av:play-circle-outline"></iron-icon>
      <iron-icon class="icon pause" icon="av:pause-circle-outline"></iron-icon>
      <iron-icon class="icon error" icon="av:not-interested"></iron-icon>-->

      <!-- Title -->
      <div id="title">{{ title }}</div>

      <!-- Audio HTML5 element -->
      <audio id="audio" src="{{ src }}"></audio>

      <!-- Paper progress bar -->
      <paper-progress id="progress"></paper-progress>
    </div>
  </template>

</dom-module>

<script>

  Polymer({

    is: 'flat-audio-player',

    properties: {
      src: String,
      title: {
        type: String,
        value: 'Click to play this audio file'
      },
      color: {
        type: String,
        value: 'blueviolet'
      }
    },


    //
    // Register event listeners

    listeners: {
      'audio.canplay' : 'onCanPlay',
      'audio.playing' : 'onPlaying',
      'audio.pause'   : 'onPause',
      'audio.ended'   : 'onEnd',
      'audio.error'   : 'onError'
    },


    ready: function() {

      //
      // create Player defaults

      var player = this;
      player.canBePlayed = false;
      player.isPlaying = false;
      player.duration = 0;
      player.currentTime = 0;
      player.icon = '';


      //
      // Progress bar

      var progress = player.$.progress;
      progress.max = 0;
      progress.value = 0;

      //this.querySelector('#before', ':before').style.borderLeftColor(player.color);


      //
      // Audio element

      var audio = player.$.audio;

      /*var audio = document.createElement('audio');
      player.appendChild(audio);
      audio.setAttribute('id', 'audio');*/

      // check if the default naming is enabled, if not use the chrome one.
      /*if (! window.AudioContext) {
        if (! window.webkitAudioContext) {
          alert('no audiocontext found');
        }
        window.AudioContext = window.webkitAudioContext;
      }
      var context = new AudioContext();
      var audioBuffer;
      var sourceNode;

      // load the sound
      setupAudioNodes();
      //loadSound(player.src);

      function setupAudioNodes() {
        // create a buffer source node
        sourceNode = context.createBufferSource();
        // and connect to destination
        sourceNode.connect(context.destination);
      }

      // load the specified sound
      function loadSound(url) {
        var request = new XMLHttpRequest();
        request.open('GET', url, true);
        request.responseType = 'arraybuffer';

        // When loaded decode the data
        request.onload = function() {

          // decode the data
          context.decodeAudioData(request.response, function(buffer) {
            // when the audio is decoded play the sound
            //playSound(buffer);
          }, onError);
        };
        request.send();
      }


      function playSound(buffer) {
        console.log('sourceNode', sourceNode);
        sourceNode.buffer = buffer;
        sourceNode.start(0);
      }

      // log if an error occurs
      function onError(e) {
        console.log(e);
      }*/


      var ctx = new AudioContext();
      //var audio = document.getElementById('myAudio');
      var audioSrc = ctx.createMediaElementSource(audio);

      //MY connect to destination
      audioSrc.connect(ctx.destination);

      // VISUALIZER
      var analyser = ctx.createAnalyser();
      // we have to connect the MediaElementSource with the analyser
      audioSrc.connect(analyser);
      // we could configure the analyser: e.g. analyser.fftSize (for further infos read the spec)

      // frequencyBinCount tells you how many values you'll receive from the analyser
      var frequencyData = new Uint8Array(analyser.frequencyBinCount);

      // we're ready to receive some data!
      // loop
      function renderFrame() {
        //requestAnimationFrame(renderFrame);
        // update data in frequencyData
        analyser.getByteFrequencyData(frequencyData);
        // render frame based on values in frequencyData
        console.log(frequencyData);
      }
      //audio.play();
      //renderFrame();


      //
      // Title element

      var title = this.$.title;
      title.style.color = player.color;

      var wrapper = this.$.wrapper;
      var icon = player.$.icon;
      icon.style.color = player.color;


    },


    attached: function() {
      var player = this;
      //player.style.width = player.width;

      var audio = this.$.audio;


      /*window.onload = function() {
        var ctx = new AudioContext();
        //var audio = document.getElementById('myAudio');
        var audioSrc = ctx.createMediaElementSource(audio);
        var analyser = ctx.createAnalyser();
        // we have to connect the MediaElementSource with the analyser
        audioSrc.connect(analyser);
        // we could configure the analyser: e.g. analyser.fftSize (for further infos read the spec)

        // frequencyBinCount tells you how many values you'll receive from the analyser
        var frequencyData = new Uint8Array(analyser.frequencyBinCount);

        // we're ready to receive some data!
        // loop
        function renderFrame() {
          requestAnimationFrame(renderFrame);
          // update data in frequencyData
          analyser.getByteFrequencyData(frequencyData);
          // render frame based on values in frequencyData
          console.log(frequencyData);
        }
        audio.play();
        renderFrame();
      };*/

      /*

       //
       // Audio element

       audio = player.$.audio;
       ctx = new AudioContext();
       audioSrc = ctx.createMediaElementSource(audio);

       // VISUALIZER
       analyser = ctx.createAnalyser();
       // we have to connect the MediaElementSource with the analyser
       audioSrc.connect(analyser);
       // we could configure the analyser: e.g. analyser.fftSize (for further infos read the spec)

       //MY connect to destination
       analyser.connect(ctx.destination);

       // frequencyBinCount tells you how many values you'll receive from the analyser
       frequencyData = new Uint8Array(analyser.frequencyBinCount);

       // we're ready to receive some data!
       // loop
       player.renderFrame = function() {
       //requestAnimationFrame(renderFrame);
       // update data in frequencyData
       analyser.getByteFrequencyData(frequencyData);
       // render frame based on values in frequencyData
       console.log(frequencyData);
       //drawTimeDomain();
       };
       //audio.play();
       //renderFrame();

       */

      // MDN 2


      //TUT 3
      /*var canvas = document.getElementById('canvas');
       console.log('canvas', canvas);
       var canvasCtx = canvas.getContext("2d");
       console.log('canvasCtx', canvasCtx);
       var canvasHeight = 50;
       var canvasWidth = 500;

       function drawTimeDomain() {
       clearCanvas();
       for (var i = 0; i < frequencyData.length; i++) {
       var value = frequencyData[i] / 256;
       var y = canvasHeight - (canvasHeight * value) - 1;
       canvasCtx.fillStyle = 'yellow';
       canvasCtx.fillRect(i, y, 1, 1);
       }
       }
       function clearCanvas() {
       canvasCtx.clearRect(0, 0, canvasWidth, canvasHeight);
       }*/

      var progress, audio, audioCtx, audioSrc, analyser, frequencyData;



      //
      // Audio element

      audio = player.$.audio;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      //ctx = new AudioContext();
      audioSrc = audioCtx.createMediaElementSource(audio);

      // VISUALIZER
      analyser = audioCtx.createAnalyser();
      // we have to connect the MediaElementSource with the analyser
      audioSrc.connect(analyser);
      // we could configure the analyser: e.g. analyser.fftSize (for further infos read the spec)

      //MY connect to destination
      analyser.connect(audioCtx.destination);

      analyser.fftSize = 2048;
      // frequencyBinCount tells you how many values you'll receive from the analyser
      var dataArray = new Uint8Array(analyser.frequencyBinCount);

      analyser.getByteTimeDomainData(dataArray);

      player.draw = function() {
        drawVisual = requestAnimationFrame(player.draw);
        analyser.getByteTimeDomainData(dataArray);
        canvasCtx.fillStyle = 'rgb(200, 200, 200)';
        canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);
      };

      // we're ready to receive some data!
      // loop
      player.renderFrame = function() {
        //requestAnimationFrame(renderFrame);
        // update data in frequencyData
        analyser.getByteFrequencyData(frequencyData);
        // render frame based on values in frequencyData
        console.log(frequencyData);
        drawTimeDomain();
      };
      //audio.play();
      //renderFrame();


      // MDN 2


      //TUT 3
      var canvas = document.getElementById('canvas');
      console.log('canvas', canvas);
      var canvasCtx = canvas.getContext("2d");
      console.log('canvasCtx', canvasCtx);
      var canvasHeight = 50;
      var canvasWidth = 500;

      function drawTimeDomain() {
        clearCanvas();
        for (var i = 0; i < frequencyData.length; i++) {
          var value = frequencyData[i] / 256;
          var y = canvasHeight - (canvasHeight * value) - 1;
          canvasCtx.fillStyle = 'yellow';
          canvasCtx.fillRect(i, y, 1, 1);
        }
      }
      function clearCanvas() {
        canvasCtx.clearRect(0, 0, canvasWidth, canvasHeight);
      }
    },


    //
    // Play/Pause controls

    playPause: function(e){
      e.preventDefault();

      var player = this;

      if ( player.canBePlayed ) {
        return player.isPlaying ? player.$.audio.pause() : player.$.audio.play();
      } else {
        console.log('I cant play it: ' + this.$.audio.src);
      }
    },


    //
    // when audio file can be played in user's browser

    onCanPlay: function() {
      console.log('can be played!!!');
      var player = this;
      player.icon = 'av:album';
      player.canBePlayed = true;
      player.duration = player.$.audio.duration;
      player.$.progress.max = player.duration * 1000;
    },

/*
    //
    // when Player starts playing

    onPlaying: function() {
      console.log('It\'s playing...', audio);
      var player = this;
      player.isPlaying = true;

      (function startProgressTimer(){
        console.log('startProgressTimer fired');
        var timer = this;
        if (timer.sliderUpdateInterval) { clearInterval(timer.sliderUpdateInterval); }
        timer.sliderUpdateInterval = setInterval(function(){
          if ( player.isPlaying ) {
            player.$.progress.value = player.$.audio.currentTime * 1000;
            player.currentTime = player.$.audio.currentTime;
          } else {
            clearInterval(timer.sliderUpdateInterval);
          }
        }, 120);
      })();
    },


    //
    // when Player is paused

    onPause: function() {
      console.log('It\'s plaused.');
      var player = this;
      player.isPlaying = false;
      player.$.progress.value = player.currentTime * 1000;
    },


    //
    // when Player ended playing an audio file

    onEnd: function() {
      console.log('It\'s ended.');
      var player = this;
      player.isPlaying = false;
      player.currentTime = 0;
    },*/


    //
    // on file load error

    onError: function() {
      console.log('Error loading this file: ' + this.src);
      this.icon = 'av:not-interested';
    },

    onMouseenter: function() {
      var player = this;

      if (player.canBePlayed) {

        if (player.isPlaying) {
          player.icon = 'av:pause-circle-outline';

        } else {
          player.icon = 'av:play-circle-outline';
          player.$.title.style.color = '#000';
          player.classList.add('hovered');
        }
      } else {

      }

    },

    onMouseleave: function() {
      var player = this;
      if (player.canBePlayed) {
        player.icon = 'av:album';
        if (player.isPlaying) {

        } else {
          player.$.title.style.color = player.color;
          player.classList.remove('hovered');
        }

      } else {

      }

    }
  });

</script>
